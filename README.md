### 1. **Data Structures and Algorithms (DSA)**
This was the most prominent category, featuring a variety of subtopics:

#### Arrays and Strings
- Counting the number of 0's in given ranges of a binary array.
- Generating all sorted subsequences of a string.
- Finding the maximum length of a subarray with a sum of 0.
- Identifying all pairs in an array with the minimum difference.
- Shuffling an array so no element remains at its original index (derangement).
- Grouping anagrams from an array of strings.
- Finding the next greater element for each array element.
- Constructing the smallest number greater than a given number (as a string), using the same set of digits.
- Minimizing the sum of an array after a fixed number of operations (where an element can be repetitively halved).

#### Linked Lists
- Merging a linked list between two specified indexes.
- Reversing a linked list in groups of K nodes.
- Finding the middle node of a linked list.
- Completely reversing a linked list.
- Removing duplicate elements.
- Incrementing a number represented as a linked list by one.

#### Trees
- Trimming a Binary Search Tree (BST).
- Checking if a given binary tree is a BST.

#### Stacks and Queues
- Real-life applications of stacks and queues.
- Designing a stack that supports push, pop, and getMin in O(1) time.
- Implementing the stack data structure and its operations.

#### Heaps/Priority Queues
- Using heaps to minimize array sum after k operations.
- Finding the minimum possible total weight of chocolates after 'd' days of eating half each day.

#### Graphs
- Modeling delivery or path-finding problems as grid-based minimum-cost path graph problems.

#### Searching and Sorting
- Checking if a number is a perfect cube using binary search.
- Finding the closest pair of numbers (one from each of two sorted arrays) to a given value.

#### Dynamic Programming
- Solving unbounded knapsack problems (maximizing number of items/notebooks within a budget).

### 2. **Object-Oriented Programming (OOPs)**
- **Core Concepts:** Polymorphism, inheritance, function overloading vs. function overriding.
- **C++ Specific:** 
  - Function overloading vs. operator overloading.
  - Virtual functions, pure virtual functions, abstract classes.
  - Virtual destructors.
  - Access modifiers and their real-world applications.
  - Smart pointers.
  - Constructors and Singleton pattern.
  - Implementation of multithreading.

### 3. **Database Management Systems (DBMS)**
- **SQL vs NoSQL:** Differences between MySQL and MongoDB, use cases, ACID properties.
- **Indexing:** Concept, implementation (including prime indexing), types, and scenarios where indexing is not beneficial.
- **Sharding & Partitioning:** Definitions, implementation details for sharding, difference between partitioning and indexing.
- **Joins:** Types of joins; difference between inner and outer joins.
- **Other:** ACID properties, SQL views, database collisions.

### 4. **Operating Systems (OS)**
- Difference between a thread and a process.
- Strategies for executing a file on multiple computers at a specific time (including Task Scheduler).
- Multithreading concepts.

### 5. **Puzzles and Aptitude**
- Logic puzzle involving a king, 10 gold bars, and a thief using a minimum number of weightings.
- Puzzle involving three switches and three bulbs to determine the switch-bulb mapping.

### 6. **Project Discussion and Resume**
- Detailed review of projects and resume items (not specified, but mentioned as part of the interviews).

**Key areas emphasized in Adobe's interview process:**  
- Strong fundamentals in **DSA** (across all classic structures),  
- Proficiency in **OOPs** (especially in C++),  
- Solid understanding of **DBMS** and **OS**,  
- Ability to solve real-world problems and logic puzzles,  
- Clarity on personal contributions in projects and past experience.  
